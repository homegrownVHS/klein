<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Donut Tunnel Journey</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { 
            margin: 0; 
            background: #000; 
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

    </style>
</head>
<body>

    
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000011, 1); // Darker background for better lighting contrast
        document.body.appendChild(renderer.domElement);

        // Bright, striking lighting for visual impact
        const ambientLight = new THREE.AmbientLight(0x707070, 1.1); // Even higher ambient light
        scene.add(ambientLight);

        // Reduced directional light for subtle depth
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(20, 15, 10);
        directionalLight.target.position.set(0, 0, 0);
        scene.add(directionalLight);

        // Create simple donut with animated color-cycling pattern
        function createDonutTunnel() {
            const majorRadius = 20;
            const minorRadius = 6;
            
            // Donut geometry - viewed from inside (higher resolution to reduce seams)
            const torusGeometry = new THREE.TorusGeometry(majorRadius, minorRadius, 64, 128);
            
            // Dynamic pattern material (higher resolution for smoother appearance)
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            
            // Function to interpolate between colors smoothly
            function interpolateColor(color1, color2, t) {
                const r1 = parseInt(color1.substr(1, 2), 16);
                const g1 = parseInt(color1.substr(3, 2), 16);
                const b1 = parseInt(color1.substr(5, 2), 16);
                
                const r2 = parseInt(color2.substr(1, 2), 16);
                const g2 = parseInt(color2.substr(3, 2), 16);
                const b2 = parseInt(color2.substr(5, 2), 16);
                
                const r = Math.round(r1 + (r2 - r1) * t);
                const g = Math.round(g1 + (g2 - g1) * t);
                const b = Math.round(b1 + (b2 - b1) * t);
                
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
            
            // Function to update the pattern with moving circles
            function updatePattern(time) {
                const patternSize = 32; // Double the pattern size for higher resolution canvas
                
                // Torus parameters for 3D mapping (must match geometry)
                const majorRadius = 20;
                const minorRadius = 6;
                
                for (let x = 0; x < canvas.width; x += patternSize) {
                    for (let y = 0; y < canvas.height; y += patternSize) {
                        // Toroidal LCD Screen - Map canvas directly to torus surface (1:1 mapping)
                        // Canvas coordinates directly represent torus surface coordinates
                        const screenU = x / canvas.width;  // 0-1 around the torus
                        const screenV = y / canvas.height; // 0-1 around the tube
                        
                        // Determine which zone/screen this pixel belongs to
                        const zoneCount = 6;
                        const zone = Math.floor(screenU * zoneCount);
                        
                        // Default background
                        let hue = 240;
                        let saturation = 30;
                        let lightness = 10;
                        
                        // Different graphics for each zone
                        if (zone === 0) {
                            // Zone 0: Classic arcade - Pac-Man style
                            const dotGrid = 8;
                            const dotSpaceU = 1 / dotGrid;
                            const dotSpaceV = 1 / dotGrid;
                            const localU = (screenU * zoneCount) % 1;
                            
                            for (let i = 0; i < dotGrid; i++) {
                                for (let j = 0; j < dotGrid; j++) {
                                    const dotU = i * dotSpaceU + 0.05;
                                    const dotV = j * dotSpaceV + 0.05;
                                    
                                    let distU = Math.abs(localU - dotU);
                                    let distV = Math.abs(screenV - dotV);
                                    const distance = Math.sqrt(distU * distU + distV * distV);
                                    
                                    if (distance < 0.02) {
                                        hue = 60; // Yellow dots
                                        saturation = 100;
                                        lightness = 70;
                                    }
                                }
                            }
                            
                            // Moving ghost
                            const ghostU = (time * 0.3) % 1;
                            const ghostV = 0.5 + Math.sin(time * 2) * 0.3;
                            let distU = Math.abs(localU - ghostU);
                            let distV = Math.abs(screenV - ghostV);
                            if (Math.sqrt(distU * distU + distV * distV) < 0.06) {
                                hue = 300; // Purple ghost
                                saturation = 80;
                                lightness = 60;
                            }
                            
                        } else if (zone === 1) {
                            // Zone 1: Matrix-style falling code
                            const localU = (screenU * zoneCount) % 1;
                            const columns = 12;
                            const colWidth = 1 / columns;
                            const col = Math.floor(localU / colWidth);
                            
                            const fallSpeed = time * 2 + col * 0.5;
                            const charV = (fallSpeed + Math.sin(col * 2) * 0.5) % 1.2;
                            
                            if (Math.abs(screenV - charV) < 0.05 && charV < 1) {
                                hue = 120; // Green matrix
                                saturation = 100;
                                lightness = 70 - Math.abs(screenV - charV) * 400;
                            }
                            
                        } else if (zone === 2) {
                            // Zone 2: Plasma/lava lamp effect
                            const localU = (screenU * zoneCount) % 1;
                            const blob1 = Math.sin(localU * 8 + time * 1.5) * Math.cos(screenV * 6 + time * 1.2);
                            const blob2 = Math.cos(localU * 5 + time * 0.8) * Math.sin(screenV * 9 + time * 2);
                            const plasma = (blob1 + blob2) * 0.5;
                            
                            if (plasma > 0.2) {
                                hue = (plasma * 180 + time * 60) % 360;
                                saturation = 80 + plasma * 20;
                                lightness = 30 + plasma * 40;
                            }
                            
                        } else if (zone === 3) {
                            // Zone 3: Geometric patterns - triangles and hexagons
                            const localU = (screenU * zoneCount) % 1;
                            const scale = 8;
                            const triU = (localU * scale + time * 0.5) % 1;
                            const triV = (screenV * scale + time * 0.3) % 1;
                            
                            // Triangle pattern
                            if ((triU + triV) % 0.5 < 0.1 || Math.abs(triU - triV) % 0.5 < 0.1) {
                                hue = (triU * 180 + triV * 180 + time * 40) % 360;
                                saturation = 85;
                                lightness = 50;
                            }
                            
                        } else if (zone === 4) {
                            // Zone 4: Retro waveform/oscilloscope
                            const localU = (screenU * zoneCount) % 1;
                            const waveform = 0.5 + 0.3 * Math.sin(localU * 20 + time * 3) * Math.cos(localU * 8 + time);
                            const lineThickness = 0.03;
                            
                            if (Math.abs(screenV - waveform) < lineThickness) {
                                const intensity = 1 - Math.abs(screenV - waveform) / lineThickness;
                                hue = 180; // Cyan scope line
                                saturation = 100;
                                lightness = 40 + intensity * 40;
                            }
                            
                            // Grid background
                            if (Math.abs((localU * 10) % 1 - 0.5) < 0.02 || Math.abs((screenV * 10) % 1 - 0.5) < 0.02) {
                                hue = 180;
                                saturation = 60;
                                lightness = 15;
                            }
                            
                        } else if (zone === 5) {
                            // Zone 5: Space invaders style
                            const localU = (screenU * zoneCount) % 1;
                            const invaderRows = 4;
                            const invaderCols = 6;
                            
                            for (let row = 0; row < invaderRows; row++) {
                                for (let col = 0; col < invaderCols; col++) {
                                    const invU = (col / invaderCols) + 0.08;
                                    const invV = (row / invaderRows) + 0.1 + Math.sin(time * 0.5 + col) * 0.02;
                                    
                                    let distU = Math.abs(localU - invU);
                                    let distV = Math.abs(screenV - invV);
                                    
                                    if (distU < 0.04 && distV < 0.05) {
                                        hue = (row * 60 + time * 20) % 360;
                                        saturation = 90;
                                        lightness = 60;
                                    }
                                }
                            }
                            
                            // Player ship at bottom
                            const playerU = 0.5 + Math.sin(time * 1.5) * 0.3;
                            if (Math.abs(localU - playerU) < 0.05 && Math.abs(screenV - 0.9) < 0.03) {
                                hue = 120; // Green player ship
                                saturation = 100;
                                lightness = 70;
                            }
                        }
                        
                        // Convert HSV to RGB
                        function hsvToRgb(h, s, v) {
                            h = h / 60;
                            const c = v * s;
                            const x = c * (1 - Math.abs((h % 2) - 1));
                            const m = v - c;
                            let r, g, b;
                            
                            if (h < 1) { r = c; g = x; b = 0; }
                            else if (h < 2) { r = x; g = c; b = 0; }
                            else if (h < 3) { r = 0; g = c; b = x; }
                            else if (h < 4) { r = 0; g = x; b = c; }
                            else if (h < 5) { r = x; g = 0; b = c; }
                            else { r = c; g = 0; b = x; }
                            
                            return [(r + m), (g + m), (b + m)];
                        }
                        
                        const [r, g, b] = hsvToRgb(hue, saturation / 100, lightness / 100);
                        const brightness = 1.0; // Consistent brightness for LCD screen effect
                        
                        // Square colors
                        const squareR = Math.floor(255 * r * brightness);
                        const squareG = Math.floor(255 * g * brightness);
                        const squareB = Math.floor(255 * b * brightness);
                        
                        // Circle colors - slightly different hue
                        const circleHue = (hue + 60) % 360;
                        const [cr, cg, cb] = hsvToRgb(circleHue, 0.7, 0.8);
                        const circleR = Math.floor(255 * cr * brightness);
                        const circleG = Math.floor(255 * cg * brightness);
                        const circleB = Math.floor(255 * cb * brightness);
                        
                        // Draw square
                        ctx.fillStyle = `rgb(${squareR}, ${squareG}, ${squareB})`;
                        ctx.fillRect(x, y, patternSize, patternSize);
                        
                        // Square border
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x, y, patternSize, patternSize);
                        
                        // Keep circles centered in their squares (no animation)
                        const animatedCircleX = x + patternSize/2;
                        const animatedCircleY = y + patternSize/2;
                        
                        // Draw animated circle
                        ctx.fillStyle = `rgb(${circleR}, ${circleG}, ${circleB})`;
                        ctx.beginPath();
                        ctx.arc(animatedCircleX, animatedCircleY, patternSize/4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Circle border
                        ctx.strokeStyle = '#000000';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }
            }
            
            updatePattern(0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(16, 8);
            
            // Improve texture filtering to reduce seams
            texture.magFilter = THREE.LinearFilter;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                side: THREE.BackSide, // View from inside
                shininess: 30,
                specular: 0x222222
            });
            
            const torus = new THREE.Mesh(torusGeometry, material);
            scene.add(torus);
            
            return { torus, majorRadius, minorRadius, texture, canvas, updatePattern };
        }

        const donut = createDonutTunnel();

        // ===== EASY CAMERA CONTROLS - TWEAK THESE VALUES =====
        let cameraX = 0;        // Left/Right position
        let cameraY = 25;        // Up/Down position  
        let cameraZ = 0;        // Forward/Back position
        let lookX = 0;          // Where to look X
        let lookY = 0;          // Where to look Y
        let lookZ = 1;          // Where to look Z
        let autoMove = false;   // Set to true for automatic movement
        let cameraAngle = 0;    // For auto movement
        

        
        // Make sure canvas can receive focus
        renderer.domElement.tabIndex = 1;
        renderer.domElement.focus();
        
        function animate() {
            requestAnimationFrame(animate);

            if (autoMove) {
                // Automatic movement (set autoMove = true above)
                cameraAngle += 0.002;
                cameraX = Math.cos(cameraAngle) * 20;
                cameraZ = Math.sin(cameraAngle) * 20;
            }
            
            // Set camera position using the variables above
            camera.position.set(cameraX, cameraY, cameraZ);
            camera.lookAt(lookX, lookY, lookZ);
            


            // Update color cycling pattern
            const time = Date.now() * 0.001; // Convert to seconds
            donut.updatePattern(time);
            donut.texture.needsUpdate = true;

            // Animate pattern position
            donut.texture.offset.x += 0.001;

            // Simple lighting animation to highlight the internal geometry depth
            directionalLight.position.x = 20 + Math.cos(time * 0.4) * 5;
            directionalLight.position.y = 15 + Math.sin(time * 0.3) * 3;
            directionalLight.position.z = 10 + Math.sin(time * 0.5) * 4;

            renderer.render(scene, camera);
        }
        
        // Add keyboard controls for manual positioning
        const keys = {};
        
        document.addEventListener('keydown', (event) => {
            keys[event.key.toLowerCase()] = true;
            event.preventDefault();
        });
        
        document.addEventListener('keyup', (event) => {
            keys[event.key.toLowerCase()] = false;
            event.preventDefault();
        });
        
        function handleMovement() {
            const moveSpeed = 0.1;
            if (keys['w']) camera.position.y += moveSpeed;
            if (keys['s']) camera.position.y -= moveSpeed;
            if (keys['a']) camera.position.x -= moveSpeed;
            if (keys['d']) camera.position.x += moveSpeed;
            if (keys['q']) camera.position.z += moveSpeed;
            if (keys['e']) camera.position.z -= moveSpeed;
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
