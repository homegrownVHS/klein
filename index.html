<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Donut Tunnel Journey</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { 
            margin: 0; 
            background: #000; 
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

    </style>
</head>
<body>

    
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000011, 1); // Darker background for better lighting contrast
        document.body.appendChild(renderer.domElement);

        // Bright, striking lighting for visual impact
        const ambientLight = new THREE.AmbientLight(0x707070, 1.1); // Even higher ambient light
        scene.add(ambientLight);

        // Reduced directional light for subtle depth
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight.position.set(20, 15, 10);
        directionalLight.target.position.set(0, 0, 0);
        scene.add(directionalLight);

        // Create simple donut with animated color-cycling pattern
        function createDonutTunnel() {
            const majorRadius = 20;
            const minorRadius = 6;
            
            // Donut geometry - viewed from inside (higher resolution to reduce seams)
            const torusGeometry = new THREE.TorusGeometry(majorRadius, minorRadius, 64, 128);
            
                        // Dynamic pattern material (higher resolution for smoother appearance)
            const canvas = document.createElement('canvas');
            canvas.width = 1056;  // Evenly divisible by 66 (16 squares per row)
            canvas.height = 1056; // Evenly divisible by 66 (16 squares per column)
            const ctx = canvas.getContext('2d');
            
            // Function to interpolate between colors smoothly
            function interpolateColor(color1, color2, t) {
                const r1 = parseInt(color1.substr(1, 2), 16);
                const g1 = parseInt(color1.substr(3, 2), 16);
                const b1 = parseInt(color1.substr(5, 2), 16);
                
                const r2 = parseInt(color2.substr(1, 2), 16);
                const g2 = parseInt(color2.substr(3, 2), 16);
                const b2 = parseInt(color2.substr(5, 2), 16);
                
                const r = Math.round(r1 + (r2 - r1) * t);
                const g = Math.round(g1 + (g2 - g1) * t);
                const b = Math.round(b1 + (b2 - b1) * t);
                
                return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            }
            
            // Function to update the pattern with moving circles
            function updatePattern(time) {
                const patternSize = 66; // Much larger squares for better texture and detail visibility
                
                // Torus parameters for 3D mapping (must match geometry)
                const majorRadius = 20;
                const minorRadius = 6;
                
                for (let x = 0; x < canvas.width; x += patternSize) {
                    for (let y = 0; y < canvas.height; y += patternSize) {
                        // Toroidal LCD Screen - Map canvas directly to torus surface (1:1 mapping)
                        // Canvas coordinates directly represent torus surface coordinates
                        const screenU = x / canvas.width;  // 0-1 around the torus
                        const screenV = y / canvas.height; // 0-1 around the tube
                        
                        // Use UV coordinates for seamless checkerboard (these are inherently seamless)
                        const checkerSize = 4; // Size of checkerboard squares in button units
                        const checkerU = Math.floor((screenU * 16) / checkerSize); // Divide 16x16 grid by checker size
                        const checkerV = Math.floor((screenV * 16) / checkerSize); // Divide 16x16 grid by checker size
                        
                        // Create alternating checkerboard pattern
                        const isChecker = (checkerU + checkerV) % 2;
                        const baseZone = Math.floor(screenU * 12); // 12 base color zones
                        const zone = baseZone + (isChecker * 12); // Offset every other checker square
                        
                        // Fresh, unique color palette - no rainbow, just beautiful combinations
                        const palette = [
                            [0.9, 0.1, 0.3],    // Deep crimson
                            [1.0, 0.4, 0.2],    // Coral
                            [1.0, 0.6, 0.8],    // Soft pink
                            [0.8, 0.3, 0.8],    // Lavender
                            [0.4, 0.2, 0.9],    // Deep purple
                            [0.2, 0.4, 0.8],    // Steel blue
                            [0.1, 0.6, 0.9],    // Sky blue
                            [0.3, 0.8, 0.8],    // Turquoise
                            [0.2, 0.7, 0.4],    // Emerald
                            [0.5, 0.8, 0.2],    // Lime
                            [0.8, 0.9, 0.3],    // Chartreuse
                            [1.0, 0.8, 0.2],    // Golden yellow
                            [1.0, 0.6, 0.1],    // Amber
                            [0.9, 0.4, 0.1],    // Burnt orange
                            [0.7, 0.2, 0.1],    // Rust
                            [0.5, 0.1, 0.2],    // Burgundy
                            [0.3, 0.1, 0.4],    // Eggplant
                            [0.2, 0.2, 0.6],    // Navy
                            [0.1, 0.3, 0.5],    // Midnight blue
                            [0.2, 0.5, 0.6],    // Teal
                            [0.4, 0.6, 0.5],    // Sage
                            [0.6, 0.7, 0.4],    // Olive
                            [0.8, 0.7, 0.3],    // Brass
                            [0.9, 0.5, 0.2],    // Copper
                            [0.8, 0.2, 0.4],    // Rose
                            [0.6, 0.1, 0.5],    // Plum
                            [0.4, 0.0, 0.6],    // Violet
                            [0.2, 0.1, 0.7],    // Indigo
                            [0.1, 0.2, 0.8],    // Royal blue
                            [0.0, 0.4, 0.7],    // Ocean blue
                            [0.9, 0.1, 0.3]     // Back to crimson
                        ];
                        
                        // Calculate color cycling through palette
                        const cycleSpeed = time * 6.0; // Ultra-fast color cycling for maximum dynamism
                        const zoneOffset = zone * (palette.length / 24); // Distribute 24 zones across palette
                        const totalCyclePos = (cycleSpeed + zoneOffset) % palette.length;
                        
                        // Get two adjacent colors for interpolation
                        const colorIndex = Math.floor(totalCyclePos);
                        const nextColorIndex = (colorIndex + 1) % palette.length;
                        const blend = totalCyclePos - colorIndex;
                        
                        // Interpolate between colors
                        const color1 = palette[colorIndex];
                        const color2 = palette[nextColorIndex];
                        const paletteR = color1[0] * (1 - blend) + color2[0] * blend;
                        const paletteG = color1[1] * (1 - blend) + color2[1] * blend;
                        const paletteB = color1[2] * (1 - blend) + color2[2] * blend;
                        
                        // Convert to HSV for compatibility with existing code
                        function rgbToHsv(r, g, b) {
                            const max = Math.max(r, g, b);
                            const min = Math.min(r, g, b);
                            const diff = max - min;
                            
                            let hue = 0;
                            if (diff !== 0) {
                                if (max === r) hue = ((g - b) / diff) % 6;
                                else if (max === g) hue = (b - r) / diff + 2;
                                else hue = (r - g) / diff + 4;
                            }
                            hue = Math.round(hue * 60);
                            if (hue < 0) hue += 360;
                            
                            const saturation = max === 0 ? 0 : (diff / max) * 100;
                            const lightness = max * 100;
                            
                            return [hue, saturation, lightness];
                        }
                        
                        const [hue, saturation, lightness] = rgbToHsv(paletteR, paletteG, paletteB);
                        
                        // Convert HSV to RGB
                        function hsvToRgb(h, s, v) {
                            h = h / 60;
                            const c = v * s;
                            const x = c * (1 - Math.abs((h % 2) - 1));
                            const m = v - c;
                            let r, g, b;
                            
                            if (h < 1) { r = c; g = x; b = 0; }
                            else if (h < 2) { r = x; g = c; b = 0; }
                            else if (h < 3) { r = 0; g = c; b = x; }
                            else if (h < 4) { r = 0; g = x; b = c; }
                            else if (h < 5) { r = x; g = 0; b = c; }
                            else { r = c; g = 0; b = x; }
                            
                            return [(r + m), (g + m), (b + m)];
                        }
                        
                        const [r, g, b] = hsvToRgb(hue, saturation / 100, lightness / 100);
                        const brightness = 1.0; // Consistent brightness for LCD screen effect
                        
                        // Square colors
                        const squareR = Math.floor(255 * r * brightness);
                        const squareG = Math.floor(255 * g * brightness);
                        const squareB = Math.floor(255 * b * brightness);
                        
                        // Circle colors - slightly different hue
                        const circleHue = (hue + 60) % 360;
                        const [cr, cg, cb] = hsvToRgb(circleHue, 0.7, 0.8);
                        const circleR = Math.floor(255 * cr * brightness);
                        const circleG = Math.floor(255 * cg * brightness);
                        const circleB = Math.floor(255 * cb * brightness);
                        
                        // Enhanced 3D button effect with depth and shadows
                        const baseColor = `rgb(${squareR}, ${squareG}, ${squareB})`;
                        const ultraBrightColor = `rgb(${Math.min(255, squareR + 150)}, ${Math.min(255, squareG + 150)}, ${Math.min(255, squareB + 150)})`;
                        const brightColor = `rgb(${Math.min(255, squareR + 80)}, ${Math.min(255, squareG + 80)}, ${Math.min(255, squareB + 80)})`;
                        const darkColor = `rgb(${Math.max(0, squareR - 100)}, ${Math.max(0, squareG - 100)}, ${Math.max(0, squareB - 100)})`;
                        const ultraDarkColor = `rgb(${Math.max(0, squareR - 140)}, ${Math.max(0, squareG - 140)}, ${Math.max(0, squareB - 140)})`;
                        const shadowColor = `rgba(0, 0, 0, 0.6)`;
                        
                        // Draw deep shadow first (offset down-right for 3D depth)
                        const shadowOffset = 4;
                        ctx.fillStyle = shadowColor;
                        ctx.fillRect(x + shadowOffset, y + shadowOffset, patternSize - shadowOffset, patternSize - shadowOffset);
                        
                        // Create raised button gradient (top-left to bottom-right)
                        const buttonGradient = ctx.createLinearGradient(x, y, x + patternSize, y + patternSize);
                        buttonGradient.addColorStop(0, ultraBrightColor);    // Top-left highlight (light source)
                        buttonGradient.addColorStop(0.15, brightColor);     // Bright edge
                        buttonGradient.addColorStop(0.4, baseColor);        // Main surface
                        buttonGradient.addColorStop(0.85, darkColor);       // Shadow edge
                        buttonGradient.addColorStop(1, ultraDarkColor);     // Bottom-right shadow
                        
                        // Draw main button surface (slightly inset to show shadow)
                        ctx.fillStyle = buttonGradient;
                        ctx.fillRect(x, y, patternSize - shadowOffset, patternSize - shadowOffset);
                        
                        // Add beveled edges for stronger 3D effect
                        const bevelSize = 3;
                        
                        // Top highlight edge
                        ctx.fillStyle = ultraBrightColor;
                        ctx.fillRect(x, y, patternSize - shadowOffset, bevelSize);
                        
                        // Left highlight edge  
                        ctx.fillRect(x, y, bevelSize, patternSize - shadowOffset);
                        
                        // Bottom shadow edge
                        ctx.fillStyle = ultraDarkColor;
                        ctx.fillRect(x, y + patternSize - shadowOffset - bevelSize, patternSize - shadowOffset, bevelSize);
                        
                        // Right shadow edge
                        ctx.fillRect(x + patternSize - shadowOffset - bevelSize, y, bevelSize, patternSize - shadowOffset);
                        
                        // Add textural variations to squares (adjusted for 3D button surface)
                        const buttonSurface = patternSize - shadowOffset;
                        const textureVariant = Math.floor((screenU * 100 + screenV * 100) % 4); // 4 different texture types
                        
                        if (textureVariant === 0) {
                            // Brushed metal horizontal lines (on button surface only)
                            ctx.strokeStyle = `rgba(255, 255, 255, 0.1)`;
                            ctx.lineWidth = 1;
                            for (let i = 6; i < buttonSurface - 3; i += 4) {
                                ctx.beginPath();
                                ctx.moveTo(x + 3, y + i);
                                ctx.lineTo(x + buttonSurface - 3, y + i);
                                ctx.stroke();
                            }
                            
                        } else if (textureVariant === 1) {
                            // Diagonal crosshatch pattern (on button surface only)
                            ctx.strokeStyle = `rgba(255, 255, 255, 0.08)`;
                            ctx.lineWidth = 0.5;
                            for (let i = 0; i < buttonSurface * 2; i += 8) {
                                // Diagonal lines / (clipped to button surface)
                                ctx.beginPath();
                                ctx.moveTo(Math.max(x + 3, x + i), y + 3);
                                ctx.lineTo(x + 3, Math.min(y + buttonSurface - 3, y + i));
                                ctx.stroke();
                                // Diagonal lines \ (clipped to button surface)
                                ctx.beginPath();
                                ctx.moveTo(Math.min(x + buttonSurface - 3, x + buttonSurface - i), y + 3);
                                ctx.lineTo(x + buttonSurface - 3, Math.min(y + buttonSurface - 3, y + i));
                                ctx.stroke();
                            }
                            
                        } else if (textureVariant === 2) {
                            // Stippled/dotted texture (on button surface only)
                            ctx.fillStyle = `rgba(255, 255, 255, 0.12)`;
                            for (let dx = 6; dx < buttonSurface - 3; dx += 6) {
                                for (let dy = 6; dy < buttonSurface - 3; dy += 6) {
                                    ctx.beginPath();
                                    ctx.arc(x + dx, y + dy, 0.8, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                            
                        } else {
                            // Concentric circles (like vinyl record, on button surface only)
                            ctx.strokeStyle = `rgba(255, 255, 255, 0.1)`;
                            ctx.lineWidth = 0.5;
                            const centerX = x + buttonSurface / 2;
                            const centerY = y + buttonSurface / 2;
                            for (let radius = 4; radius < buttonSurface * 0.35; radius += 6) {
                                ctx.beginPath();
                                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                        
                        // Enhanced 3D highlight streak (on button surface)
                        const highlight = ctx.createLinearGradient(x, y, x + buttonSurface * 0.5, y + buttonSurface * 0.5);
                        const highlightColor = `rgba(255, 255, 255, 0.4)`; // Stronger highlight for 3D effect
                        const transparentColor = `rgba(255, 255, 255, 0)`;
                        
                        highlight.addColorStop(0, highlightColor);
                        highlight.addColorStop(1, transparentColor);
                        
                        ctx.fillStyle = highlight;
                        ctx.fillRect(x + 2, y + 2, buttonSurface * 0.4, buttonSurface * 0.4);
                        
                        // Additional corner highlight for stronger 3D button effect
                        ctx.fillStyle = `rgba(255, 255, 255, 0.6)`;
                        ctx.fillRect(x + 1, y + 1, 8, 2); // Top highlight line
                        ctx.fillRect(x + 1, y + 1, 2, 8); // Left highlight line
                        
                        // Button border (only around the raised surface, not the shadow)
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x, y, buttonSurface, buttonSurface);
                        
                        // Keep circles perfectly centered on the button surface (not including shadow)
                        const animatedCircleX = x + Math.floor(buttonSurface/2);
                        const animatedCircleY = y + Math.floor(buttonSurface/2);
                        
                        // Draw animated circle with 3D effect (smaller to fit on button surface)
                        const circleRadius = buttonSurface/5;
                        
                        // Circle shadow (slightly offset)
                        ctx.fillStyle = `rgba(0, 0, 0, 0.3)`;
                        ctx.beginPath();
                        ctx.arc(animatedCircleX + 1, animatedCircleY + 1, circleRadius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Main circle with gradient for 3D effect
                        const circleGradient = ctx.createRadialGradient(
                            animatedCircleX - circleRadius/3, animatedCircleY - circleRadius/3, 0,
                            animatedCircleX, animatedCircleY, circleRadius
                        );
                        circleGradient.addColorStop(0, `rgb(${Math.min(255, circleR + 60)}, ${Math.min(255, circleG + 60)}, ${Math.min(255, circleB + 60)})`);
                        circleGradient.addColorStop(1, `rgb(${Math.max(0, circleR - 40)}, ${Math.max(0, circleG - 40)}, ${Math.max(0, circleB - 40)})`);
                        
                        ctx.fillStyle = circleGradient;
                        ctx.beginPath();
                        ctx.arc(animatedCircleX, animatedCircleY, circleRadius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Circle highlight
                        ctx.fillStyle = `rgba(255, 255, 255, 0.4)`;
                        ctx.beginPath();
                        ctx.arc(animatedCircleX - circleRadius/4, animatedCircleY - circleRadius/4, circleRadius/3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Circle border
                        ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(animatedCircleX, animatedCircleY, circleRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                }
            }
            
            updatePattern(0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(16, 8);
            
            // Improve texture filtering to reduce seams
            texture.magFilter = THREE.LinearFilter;
            texture.minFilter = THREE.LinearMipmapLinearFilter;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                side: THREE.BackSide, // View from inside
                shininess: 30,
                specular: 0x222222
            });
            
            const torus = new THREE.Mesh(torusGeometry, material);
            scene.add(torus);
            
            return { torus, majorRadius, minorRadius, texture, canvas, updatePattern };
        }

        const donut = createDonutTunnel();

        // ===== EASY CAMERA CONTROLS - TWEAK THESE VALUES =====
        let cameraX = 0;        // Left/Right position
        let cameraY = 25;        // Up/Down position  
        let cameraZ = 0;        // Forward/Back position
        let lookX = 0;          // Where to look X
        let lookY = 0;          // Where to look Y
        let lookZ = 1;          // Where to look Z
        let autoMove = false;   // Set to true for automatic movement
        let cameraAngle = 0;    // For auto movement
        

        
        // Make sure canvas can receive focus
        renderer.domElement.tabIndex = 1;
        renderer.domElement.focus();
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update time with dynamic variations
            const time = Date.now() * 0.001; // Convert to seconds

            if (autoMove) {
                // Constant speed camera movement around the donut
                cameraAngle += 0.02; // Very fast constant rotation speed
                
                // Constant radius orbital movement
                const primaryRadius = 20; // Fixed distance for steady movement
                
                cameraX = Math.cos(cameraAngle) * primaryRadius;
                cameraZ = Math.sin(cameraAngle) * primaryRadius;
                
                // Keep vertical position stable
                cameraY = 28; // Fixed height for consistent viewing
                
                // Dynamic look-at point for more immersive movement
                lookX = Math.sin(time * 0.1) * 2;
                lookY = Math.cos(time * 0.12) * 1.5;
                lookZ = Math.cos(time * 0.08) * 2;
            }
            
            // Set camera position with enhanced movement
            camera.position.set(cameraX, cameraY, cameraZ);
            camera.lookAt(lookX, lookY, lookZ);

            // Update color cycling pattern
            donut.updatePattern(time);
            donut.texture.needsUpdate = true;

            // Constant texture animation movement
            const textureSpeedX = 0.003; // Constant horizontal speed
            const textureSpeedY = 0.001; // Constant vertical speed
            donut.texture.offset.x += textureSpeedX;
            donut.texture.offset.y += textureSpeedY;

            // Constant speed lighting with steady orbital movement
            const lightRadius = 25;
            const lightAngle1 = time * 1.2; // Constant rotation speed
            const lightAngle2 = time * 1.8; // Constant rotation speed (different rate for complexity)
            directionalLight.position.x = Math.cos(lightAngle1) * lightRadius + Math.cos(lightAngle2) * 8;
            directionalLight.position.y = 15 + Math.sin(lightAngle1) * 10;
            directionalLight.position.z = Math.sin(lightAngle1) * lightRadius + Math.sin(lightAngle2) * 8;
            
            // Constant ambient light intensity
            ambientLight.intensity = 1.1;

            renderer.render(scene, camera);
        }
        
        // Add keyboard controls for manual positioning
        const keys = {};
        
        document.addEventListener('keydown', (event) => {
            keys[event.key.toLowerCase()] = true;
            event.preventDefault();
        });
        
        document.addEventListener('keyup', (event) => {
            keys[event.key.toLowerCase()] = false;
            event.preventDefault();
        });
        
        function handleMovement() {
            const moveSpeed = 0.1;
            if (keys['w']) camera.position.y += moveSpeed;
            if (keys['s']) camera.position.y -= moveSpeed;
            if (keys['a']) camera.position.x -= moveSpeed;
            if (keys['d']) camera.position.x += moveSpeed;
            if (keys['q']) camera.position.z += moveSpeed;
            if (keys['e']) camera.position.z -= moveSpeed;
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
